<!DOCTYPE html><html class="no-js" lang="en"><head><meta charset="utf-8" /><title>Angular Cached Resource | Bites from Good Eggs</title><meta name="author" content="Max Edmands" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="/favicon.ico?v=2" /><link rel="stylesheet" href="/styles/main.css" /><link rel="alternate" title="RSS" type="application/rss+xml" href="/rss" /><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-26193287-5', 'github.io');
ga('send', 'pageview');</script></head><body><header><h1><a href="/">Bites</a></h1><ul class="unstyled nav"><li><a href="/">Blog</a></li><li><a href="/open_source/">Open Source</a></li><li><a href="/news/">News</a></li></ul></header><div id="main"><div id="content"><div><article class="post" role="article"><header><img class="author" src="http://fpio.goodeggs.com/api/file/4HBn1HQRvqTW9BdESZVX/convert?w=150&amp;h=150&amp;fit=crop&amp;align=faces&amp;cache=true" alt="Max Edmands" /><h1 class="entry-title">Angular Cached Resource</h1><p class="meta"><a class="entry-author-name" href="/authors/max_edmands/">Max Edmands</a> on <time datetime="2014-04-24T19:00:00.000Z">April 24th, 2014</time></p></header><div class="entry-content"><p><a href="http://github.com/goodeggs/angular-cached-resource">Angular Cached Resource</a> is a module for <a href="http://angularjs.org/">AngularJS</a> that provides a clean
way to interact with server-side data sources, even when the browser cannot always connect to the server.
It&#39;s basically an offline-compatible wrapper around Angular&#39;s core <a href="http://docs.angularjs.org/api/ngResource/service/$resource">Resource</a> module.
<a href="http://github.com/goodeggs/angular-cached-resource">Fork it on GitHub</a> or install it like so:</p>
<pre><code class="bash">&gt; bower install angular-cached-resource
&gt;         <span class="hljs-comment"># OR:</span>
&gt; npm install angular-cached-resource
&gt;         <span class="hljs-comment"># OR:</span>
&gt; git clone https://github.com/goodeggs/angular-cached-resource</code></pre>

<!--more-->

<h2 id="starting-out-using-angular-s-resource-module">Starting out: using Angular&#39;s Resource module</h2>
<p>If you haven&#39;t used angular&#39;s <a href="http://docs.angularjs.org/api/ngResource/service/$resource">Resource</a> module, you&#39;re missing out. They create this excellently
straightforward way to communicate with a REST-complient server from the client. Here&#39;s an example of
POSTing a resource. It will make a <code>POST</code> request against <code>/entries/announcing-angular-cached-resource</code>,
and when it is done, it will display an alert on the screen:</p>
<p><strong>Ex. 1: <code>POST</code> with Angular&#39;s Resource module</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> Entry = $resource(<span class="hljs-string">'/entries/:slug'</span>, {slug: <span class="hljs-string">'@slug'</span>});

<span class="hljs-keyword">var</span> announcement = <span class="hljs-keyword">new</span> Entry();
announcement.slug = <span class="hljs-string">'announcing-angular-cached-resource'</span>;
announcement.title = <span class="hljs-string">'Announcing Angular Cached Resource'</span>;
announcement.body = <span class="hljs-string">'Here is why Angular Cached Resource is awesome!'</span>;

announcement.$save(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  alert(<span class="hljs-string">'Saved announcement.'</span>);
});</code></pre>

<p>Trouble is, what if the server is down, or if the browser can&#39;t connect to the internet when it&#39;s trying
to save the resource? That&#39;s where <a href="http://github.com/goodeggs/angular-cached-resource">Angular Cached Resource</a> comes in.</p>
<h2 id="upgrade-using-angular-cached-resource">Upgrade: using Angular Cached Resource</h2>
<p>With almost exactly the same setup (there are a few differences, which I will explain in a second),
the same code will remember your intention to save the announcement, and repeatedly attempt to save it
again until it succeeds! It will even keep trying after the page reloads, for real serious offline web
application requirements. (If you&#39;re doing this, you might also want to use the
<a href="http://appcache.offline.technology/">HTML5 application cache</a>, which works great with this module!)</p>
<p>Below is an example of Angular Cached Resource doing the same thing. The only difference is that we&#39;re
referencing <code>$cachedResource</code> instead of <code>$resource</code>, and we&#39;ve given the resource a &quot;key&quot;, in this case
<code>entries</code>. This will allow us to refer to the same resource even between refreshes or page loads.</p>
<p><strong>Ex. 2: <code>POST</code> with Angular Cached Resource</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> Entry = <span class="hljs-keyword">new</span> $cachedResource(<span class="hljs-string">'entries'</span>, <span class="hljs-string">'/entries/:slug'</span>, {slug: <span class="hljs-string">'@slug'</span>});

<span class="hljs-keyword">var</span> announcement = <span class="hljs-keyword">new</span> Entry();
announcement.slug = <span class="hljs-string">'announcing-angular-cached-resource'</span>;
announcement.title = <span class="hljs-string">'Announcing Angular Cached Resource'</span>;
announcement.body = <span class="hljs-string">'Here is why Angular Cached Resource is awesome!'</span>;

announcement.$save(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  alert(<span class="hljs-string">'Saved announcement.'</span>);
});</code></pre>

<p>This will also work with <code>DELETE</code> calls -- by default, a Resource instance gets a <code>$delete</code> and a <code>$remove</code>
method, and both will accomplish this.</p>
<h2 id="reading-from-the-server-and-also-from-the-cache">Reading from the server, and also from the cache</h2>
<p>But what if you want to <code>GET</code> a saved resource from the server? As it turns out, this is pretty straightforward.
The code snippet below will hit the <code>/entries/building-offline-web-applications</code> endpoint with a <code>GET</code> request.</p>
<p><strong>Ex. 3: <code>GET</code> with Angular Cached Resource</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> otherPost = Entry.get({slug: <span class="hljs-string">'building-offline-web-applications'</span>});
otherPost.$promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  alert(<span class="hljs-string">'Downloaded post: '</span> + otherPost.title);
});</code></pre>

<p>The first time this module downloads (or saves) any resource, it will cache a copy of that resource in your
browser. That means that the next time you try and load the resource, the $promise will <strong>immediately</strong>
resolve (and, in the code snippet above, you&#39;ll see the alert with the title of the post right away).
This should provide you with a nice speed boost.</p>
<p>The module will, however, still make a request against the server endpoint. When it receives a response, it
will update the cache entry with the new values, and it will also update the value of <code>otherPost</code> in place.
It will also trigger a <code>$digest</code>, so that angular can update its views if there are any that use that data.
Magic! (Finally, if you need to listen specifically for the completed HTTP request, you can use the <code>$httpPromise</code>
on the resource object instead of the regular <code>$promise</code> object.)</p>
<h2 id="querying-for-multiple-resources-at-once">Querying for multiple resources at once</h2>
<p>Finally, you can use Angular Cached Resource to query the server for a list of resources. Below is an example
of this kind of query, which will make a <code>GET</code> request against <code>/entries?tag=angular-cached-resource</code>:</p>
<p><strong>Ex. 4: Query-style <code>GET</code> with Angular Cached Resource</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> postList = Entry.query({tag: <span class="hljs-string">'angular-cached-resource'</span>});
postList.$promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  alert(<span class="hljs-string">'Downloaded '</span> + postList.length + <span class="hljs-string">' posts.'</span>);
});</code></pre>

<p>The response is an array with a <code>$promise</code> and an <code>$httpPromise</code> object on it, which work like before. When the
HTTP request is complete, the module will save each returned resource in the cache seperately, so that if you
make a GET request against a specific instance, it will come from the cache, too.</p>
<h2 id="conclusion-and-a-warning-">Conclusion (and a warning)</h2>
<p>Angular&#39;s Resource module is a straightforward abstraction over AJAX that makes for some really clean code. And
if you&#39;re already using it, then switching to Angular Cached Resource is really easy:</p>
<p><strong>Ex. 5: Direct comparison of <code>$resource</code> vs <code>$cachedResource</code></strong></p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> Entry = $resource(<span class="hljs-string">'/entries/:slug'</span>, {slug: <span class="hljs-string">'@slug'</span>});
<span class="hljs-keyword">var</span> Entry = $cachedResource(<span class="hljs-string">'entries'</span>, <span class="hljs-string">'/entries/:slug'</span>, {slug: <span class="hljs-string">'@slug'</span>});</code></pre>

<p>For almost no added effort, you get a vastly improved user experience, where a constant internet connection is no longer
required to read or write from a server.</p>
<p>There&#39;s a caveat, however: <code>$cachedResource</code> stores its data in your browser&#39;s <a href="http://www.w3.org/TR/webstorage/#the-localstorage-attribute"><code>localStorage</code></a> cache. There&#39;s
a hard 5MB limit on this cache for most browsers, and if you&#39;re not careful, you could end up filling it up pretty quickly.
So a responsible user of this module should practice careful cache management. Here are a few techniques:</p>
<p><strong>Ex. 6: Ways to clear the localStorage cache</strong></p>
<pre><code class="javascript">$cachedResource.clearAll(); <span class="hljs-comment">// remove everything from cache</span>
$cachedResource.clearAll({exceptFor: [<span class="hljs-string">'vegetables'</span>]}); <span class="hljs-comment">// remove all the resources that don't have the 'vegetable' key from the cache</span>
$cachedResource.clearUndefined(); <span class="hljs-comment">// remove all the cachedResource entries that haven't been defined since the page was loaded</span>

Entry.$clearAll(); <span class="hljs-comment">// remove all 'entries' resources from the cache</span>
Entry.$clearAll({exceptFor: {tag: <span class="hljs-string">'angular-cached-resource'</span>}); <span class="hljs-comment">// remove all 'entries' from the cache, except for ones that were returned by the provided query</span>
Entry.$clearAll({exceptFor: [{slug: <span class="hljs-string">'announcing-angular-cached-resource'</span>}]); <span class="hljs-comment">// remove all 'entries' from the cache, except for the one with the provided slug</span></code></pre>

<p>I hope you find the module useful. What other tools do you find helpful for building offline web applications?</p>
</div><footer><p class="meta"><a class="basic-alignment left" href="/open-source/chai-webdriver/">&laquo; Chai Webdriver</a></p><div id="disqus_thread"></div><script>window.disqus_shortname = 'goodeggsbytes'; window.disqus_url = 'http://bites.goodeggs.com/open_source/angular-cached-resource/'</script><script async="async" src="//goodeggsbytes.disqus.com/embed.js"></script></footer></article></div></div></div><footer><div class="mission">Our mission is to grow and sustain local food systems worldwide.</div><p>Â©2013 Good Eggs, Inc</p></footer></body></html>